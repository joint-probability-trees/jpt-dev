import os
import re
from typing import Any, Union

import numpy as np
from dnutils import ifnone, project, ifnot
from matplotlib import pyplot as plt

from .rendering import DistributionRendering
from ...base.utils import save_plot
from ...base.functions import ConstantFunction


class MatplotlibRendering(DistributionRendering):

    def plot_multinomial(
            self,
            dist: Any,
            title: str = None,
            fname: str = None,
            directory: str = '/tmp',
            pdf: bool = False,
            view: bool = False,
            horizontal: bool = False,
            max_values: bool = None,
            alphabet: bool = False,
            **kwargs
    ):
        '''Generates a ``horizontal`` (if set) otherwise `vertical` bar plot representing the variable's distribution.

        :param title:       the name of the variable this distribution represents
        :param fname:       the name of the file to be stored
        :param directory:   the directory to store the generated plot files
        :param pdf:         whether to store files as PDF. If false, a png is generated by default
        :param view:        whether to display generated plots, default False (only stores files)
        :param horizontal:  whether to plot the bars horizontally, default is False, i.e. vertical bars
        :param max_values:  maximum number of values to plot
        :param alphabet:    whether the bars are sorted in alphabetical order of the variable names. If False, the bars
                            are sorted by probability (descending); default is False
        :return:            None
        '''
        # Only save figures, do not show
        if not view:
            plt.ioff()

        max_values = min(
            ifnone(max_values, len(dist.labels)), len(dist.labels)
        )

        # prepare prob-label pairs containing only the first `max_values` highest probability tuples
        pairs = sorted(
            [
                (dist._params[idx], lbl) for idx, lbl in enumerate(dist.labels)
            ],
            key=lambda x: x[0],
            reverse=True
        )[:max_values]

        if alphabet:
            # re-sort remaining values alphabetically
            pairs = sorted(pairs, key=lambda x: x[1])

        probs = project(pairs, 0)
        labels = project(pairs, 1)

        vals = [re.escape(str(x)) for x in labels]

        x = np.arange(max_values)  # the label locations
        # width = .35  # the width of the bars
        err = [.015] * max_values

        fig, ax = plt.subplots(num=1, clear=True)
        ax.set_title(f'{title or f"Distribution of {dist._cl}"}')
        if horizontal:
            ax.barh(x, probs, xerr=err, color='cornflowerblue', label='P', align='center')
            ax.set_xlabel('%')
            ax.set_yticks(x)
            ax.set_yticklabels(vals)
            ax.invert_yaxis()
            ax.set_xlim(left=0., right=1.)

            for p in ax.patches:
                h = p.get_width() - .09 if p.get_width() >= .9 else p.get_width() + .03
                plt.text(h, p.get_y() + p.get_height() / 2,
                         f'{p.get_width():.2f}',
                         fontsize=10, color='black', verticalalignment='center')
        else:
            ax.bar(x, probs, yerr=err, color='cornflowerblue', label='P')
            ax.set_ylabel('%')
            ax.set_xticks(x)
            ax.set_xticklabels(vals)
            ax.set_ylim(bottom=0., top=1.)

            # print precise value labels on bars
            for p in ax.patches:
                h = p.get_height() - .09 if p.get_height() >= .9 else p.get_height() + .03
                plt.text(p.get_x() + p.get_width() / 2, h,
                         f'{p.get_height():.2f}',
                         rotation=90, fontsize=10, color='black', horizontalalignment='center')

        fig.tight_layout()

        save_plot(fig, directory, fname or dist.__class__.__name__, fmt='pdf' if pdf else 'svg')

        if view:
            plt.show()

        return None

    def plot_numeric(
            self,
            dist: Any,
            title: Union[str, bool] = None,
            fname: str = None,
            xlabel: str = 'value',
            directory: str = '/tmp',
            view: bool = False,
            pdf: bool = False,
            **kwargs
    ):
        '''
        Generates a plot of the piecewise linear function representing
        the variable's cumulative distribution function

        :param title:       the name of the variable this distribution represents
        :param fname:       the name of the file to be stored
        :param xlabel:      the label of the x-axis
        :param directory:   the directory to store the generated plot files
        :param pdf:         whether to store files as PDF. If false, a png is generated by default
        :param view:        whether to display generated plots, default False (only stores files)

        :return:            None
        '''
        if not os.path.exists(directory):
            os.makedirs(directory)

        if not view:
            plt.ioff()

        fig, ax = plt.subplots()
        ax.set_title(f'{title or f"CDF of {dist._cl}"}')
        ax.set_xlabel(xlabel)
        ax.set_ylabel('%')
        ax.set_ylim(-.1, 1.1)

        if len(dist.cdf.intervals) == 2:
            std = abs(dist.cdf.intervals[0].upper) * .1
        else:
            std = ifnot(
                np.std([i.upper - i.lower for i in dist.cdf.intervals[1:-1]]),
                dist.cdf.intervals[1].upper - dist.cdf.intervals[1].lower
            ) * 2

        # add horizontal line before first interval of distribution
        X = np.array([dist.cdf.intervals[0].upper - std])

        for i, f in zip(dist.cdf.intervals[:-1], dist.cdf.functions[:-1]):
            if isinstance(f, ConstantFunction):
                X = np.append(X, [np.nextafter(i.upper, i.upper - 1), i.upper])
            else:
                X = np.append(X, i.upper)

        # add horizontal line after last interval of distribution
        X = np.append(X, dist.cdf.intervals[-1].lower + std)
        X_ = np.array([dist.labels[x] for x in X])
        Y = np.array(dist.cdf.multi_eval(X))
        ax.plot(
            X_,
            Y,
            color='cornflowerblue',
            linestyle='dashed',
            label='Piecewise linear CDF from bounds',
            linewidth=2,
            markersize=12
        )

        bounds = np.array([i.upper for i in dist.cdf.intervals[:-1]])
        bounds_ = np.array([dist.labels[b] for b in bounds])
        ax.scatter(
            bounds_,
            np.asarray(dist.cdf.multi_eval(bounds)),
            color='orange',
            marker='o',
            label='Piecewise Function limits'
        )

        ax.legend(loc='upper left', prop={'size': 8})  # do we need a legend with only one plotted line?
        fig.tight_layout()

        save_plot(
            fig,
            directory,
            fname or dist.__class__.__name__,
            fmt='pdf' if pdf else 'svg'
        )

        if view:
            plt.show()
            plt.close()

        return fig


    def plot_integer(
            self,
            dist: Any,
            title: str = None,
            fname: str = None,
            directory: str = '/tmp',
            pdf: bool = False,
            view: bool = False,
            horizontal: bool = False,
            max_values: int = None,
            alphabet: bool = False,
            **kwargs
    ):
        '''Generates a ``horizontal`` (if set) otherwise `vertical` bar plot representing the variable's distribution.

        :param title:       the name of the variable this distribution represents
        :param fname:       the name of the file to be stored
        :param directory:   the directory to store the generated plot files
        :param pdf:         whether to store files as PDF. If false, a png is generated by default
        :param view:        whether to display generated plots, default False (only stores files)
        :param horizontal:  whether to plot the bars horizontally, default is False, i.e. vertical bars
        :param max_values:  maximum number of values to plot
        :param alphabet:    whether the bars are sorted in alphabetical order of the variable names. If False, the bars
                            are sorted by probability (descending); default is False
        :return:            None
        '''

        # Only save figures, do not show
        if not view:
            plt.ioff()

        # get the data
        # values_not_na = len([p for p in dist.probabilities.values() if p])
        max_values = ifnone(max_values, 20)

        # prepare prob-label pairs containing only the first `max_values` highest probability tuples
        if alphabet:
            data = list(dist.items(exhaustive=True, max_items=max_values))
        else:
            data = list(dist.sorted(exhaustive=False, max_items=max_values))
        labels = project(data, 0)
        probs = project(data, 1)
        vals = [re.escape(str(x)) for x in labels]

        n_values = len(data)
        x = np.arange(n_values)  # the label locations

        # width = .35  # the width of the bars
        err = [.015] * n_values

        fig, ax = plt.subplots()
        ax.set_title(f'{title or f"Distribution of {dist._cl}"}')
        if horizontal:
            ax.barh(x, probs, xerr=err, color='cornflowerblue', label='P', align='center')
            ax.set_xlabel('P')
            ax.set_yticks(x)
            ax.set_yticklabels(vals)
            ax.invert_yaxis()
            ax.set_xlim(left=0., right=1.)

            for p in ax.patches:
                h = p.get_width() - .09 if p.get_width() >= .9 else p.get_width() + .03
                plt.text(h, p.get_y() + p.get_height() / 2,
                         f'{p.get_width():.2f}',
                         fontsize=10, color='black', verticalalignment='center')
        else:
            ax.bar(x, probs, yerr=err, color='cornflowerblue', label='P')
            ax.set_ylabel('P')
            ax.set_xticks(x)
            ax.set_xticklabels(vals)
            ax.set_ylim(bottom=0., top=1.)

            # print precise value labels on bars
            for p in ax.patches:
                h = p.get_height() - .09 if p.get_height() >= .9 else p.get_height() + .03
                plt.text(p.get_x() + p.get_width() / 2, h,
                         f'{p.get_height():.2f}',
                         rotation=90, fontsize=10, color='black', horizontalalignment='center')

        fig.tight_layout()

        save_plot(fig, directory, fname or dist.__class__.__name__, fmt='pdf' if pdf else 'svg')

        if view:
            plt.show()

        return None